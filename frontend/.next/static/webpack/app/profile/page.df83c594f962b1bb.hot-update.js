"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/profile/page",{

/***/ "(app-pages-browser)/./src/contexts/AuthContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/AuthContext.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n// Create context\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// API instance\nconst api = axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create({\n    baseURL: \"http://localhost:3001/api\",\n    withCredentials: true\n});\n// Interceptor for token refresh\napi.interceptors.response.use((response)=>response, async (error)=>{\n    var _originalRequest_url, _originalRequest_url1, _originalRequest_url2, _error_response;\n    const originalRequest = error.config;\n    // Skip refresh token for auth endpoints to prevent loops\n    const isAuthEndpoint = ((_originalRequest_url = originalRequest.url) === null || _originalRequest_url === void 0 ? void 0 : _originalRequest_url.includes('/auth/login')) || ((_originalRequest_url1 = originalRequest.url) === null || _originalRequest_url1 === void 0 ? void 0 : _originalRequest_url1.includes('/auth/register')) || ((_originalRequest_url2 = originalRequest.url) === null || _originalRequest_url2 === void 0 ? void 0 : _originalRequest_url2.includes('/auth/verify-session'));\n    // If error is 401 and we haven't already tried to refresh and it's not an auth endpoint\n    if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401 && !originalRequest._retry && !isAuthEndpoint) {\n        originalRequest._retry = true;\n        try {\n            // Don't try to refresh here - redirect instead\n            window.location.href = '/auth/login?session=expired';\n            return Promise.reject(error);\n        } catch (refreshError) {\n            localStorage.removeItem('accessToken');\n            localStorage.removeItem('refreshToken');\n            return Promise.reject(refreshError);\n        }\n    }\n    return Promise.reject(error);\n});\n// Provider component\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const checkSessionCancelSource = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const renewSessionCancelSource = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Check if user is authenticated on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const checkAuth = async ()=>{\n            const token = localStorage.getItem('accessToken');\n            if (token) {\n                api.defaults.headers.common['Authorization'] = \"Bearer \".concat(token);\n                try {\n                    const { data } = await api.get('/auth/me');\n                    if (data.success) {\n                        setUser(data.data);\n                    } else {\n                        localStorage.removeItem('accessToken');\n                        localStorage.removeItem('refreshToken');\n                    }\n                } catch (error) {\n                    localStorage.removeItem('accessToken');\n                    localStorage.removeItem('refreshToken');\n                }\n            }\n            setIsLoading(false);\n        };\n        checkAuth();\n    }, []);\n    // Login function\n    const login = async (username, password)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            // Add more logging for debugging\n            console.log('Attempting login with:', {\n                username\n            });\n            const { data } = await api.post('/auth/login', {\n                username,\n                password\n            });\n            console.log('Login response:', data);\n            if (data.success) {\n                // Store tokens in localStorage\n                localStorage.setItem('accessToken', data.data.tokens.accessToken);\n                localStorage.setItem('refreshToken', data.data.tokens.refreshToken);\n                // Set user from response data\n                setUser(data.data.user);\n                // Set auth header for future requests\n                api.defaults.headers.common['Authorization'] = \"Bearer \".concat(data.data.tokens.accessToken);\n                // Navigate to dashboard\n                router.push('/dashboard');\n            }\n        } catch (error) {\n            console.error('Login error:', error);\n            // Type guard for error object\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Login failed');\n            } else {\n                setError('Login failed');\n            }\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Register function\n    const register = async (username, email, password)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const { data } = await api.post('/auth/register', {\n                username,\n                email,\n                password\n            });\n            if (data.success) {\n                // Store tokens in localStorage\n                localStorage.setItem('accessToken', data.data.tokens.accessToken);\n                localStorage.setItem('refreshToken', data.data.tokens.refreshToken);\n                // Set user from response data\n                setUser(data.data.user);\n                // Set auth header for future requests\n                api.defaults.headers.common['Authorization'] = \"Bearer \".concat(data.data.tokens.accessToken);\n                // Navigate to dashboard\n                router.push('/dashboard');\n            }\n        } catch (error) {\n            // Type guard for error object\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Registration failed');\n            } else {\n                setError('Registration failed');\n            }\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Logout function\n    const logout = async ()=>{\n        setIsLoading(true);\n        try {\n            // Get the refresh token from local storage\n            const refreshToken = localStorage.getItem('refreshToken');\n            if (refreshToken) {\n                // Send the refresh token with the logout request\n                await api.post('/auth/logout', {\n                    refreshToken\n                });\n            }\n            // Clear tokens from storage\n            localStorage.removeItem('accessToken');\n            localStorage.removeItem('refreshToken');\n            // Clear user state\n            setUser(null);\n            // Redirect to login page\n            router.push('/auth/login');\n        } catch (error) {\n            console.error('Logout error:', error);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Add these new functions to check and renew session\n    const checkSession = async (refreshToken)=>{\n        try {\n            // Cancel any previous request\n            if (checkSessionCancelSource.current) {\n                checkSessionCancelSource.current.cancel('Operation canceled due to new request.');\n            }\n            // Create a new cancel token\n            checkSessionCancelSource.current = axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CancelToken.source();\n            console.log('Checking session validity');\n            const response = await api.post('/auth/check-session', {\n                refreshToken\n            }, {\n                cancelToken: checkSessionCancelSource.current.token\n            });\n            return response.data.success;\n        } catch (error) {\n            if (axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isCancel(error)) {\n                console.log('Request canceled:', error.message);\n            } else {\n                console.error('Session check failed:', error);\n            }\n            return false;\n        }\n    };\n    const renewSession = async (refreshToken)=>{\n        try {\n            // Cancel any previous request\n            if (renewSessionCancelSource.current) {\n                renewSessionCancelSource.current.cancel('Operation canceled due to new request.');\n            }\n            // Create a new cancel token\n            renewSessionCancelSource.current = axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CancelToken.source();\n            console.log('Renewing session');\n            const response = await api.post('/auth/renew-session', {\n                refreshToken\n            }, {\n                cancelToken: renewSessionCancelSource.current.token\n            });\n            if (response.data.success) {\n                // Update tokens\n                const newAccessToken = response.data.data.accessToken;\n                const newRefreshToken = response.data.data.refreshToken;\n                console.log('Session renewed successfully, received new tokens');\n                localStorage.setItem('accessToken', newAccessToken);\n                if (newRefreshToken) {\n                    localStorage.setItem('refreshToken', newRefreshToken);\n                }\n                // Update authorization header\n                api.defaults.headers.common['Authorization'] = \"Bearer \".concat(newAccessToken);\n                return true;\n            }\n            return false;\n        } catch (error) {\n            if (axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isCancel(error)) {\n                console.log('Request canceled:', error.message);\n            } else {\n                console.error('Session renewal failed:', error);\n            }\n            return false;\n        }\n    };\n    // Replace the current verifySession with this modular approach\n    const verifySession = async ()=>{\n        setIsLoading(true);\n        try {\n            console.log('Starting session verification process');\n            // Get refresh token\n            const refreshToken = localStorage.getItem('refreshToken');\n            if (!refreshToken) {\n                console.error('No refresh token available');\n                await logout();\n                return false;\n            }\n            // First just check if session is valid\n            const isValid = await checkSession(refreshToken);\n            if (!isValid) {\n                console.log('Session invalid, logging out');\n                // Use the existing logout function that we know works\n                await logout();\n                return false;\n            }\n            // If valid, renew the session\n            const renewed = await renewSession(refreshToken);\n            if (!renewed) {\n                console.log('Session renewal failed, logging out');\n                await logout();\n                return false;\n            }\n            setIsLoading(false);\n            return true;\n        } catch (error) {\n            console.error('Session verification error:', error);\n            setIsLoading(false);\n            return false;\n        }\n    };\n    // Change email function\n    const changeEmail = async (newEmail, password)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const { data } = await api.post('/auth/change-email', {\n                newEmail,\n                password\n            });\n            if (data.success) {\n                // Update the user in state with new email\n                setUser((prevUser)=>prevUser ? {\n                        ...prevUser,\n                        email: newEmail\n                    } : null);\n            }\n        } catch (error) {\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Failed to update email');\n            } else {\n                setError('Failed to update email');\n            }\n            throw error;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Change password function\n    const changePassword = async (currentPassword, newPassword)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const { data } = await api.post('/auth/change-password', {\n                currentPassword,\n                newPassword\n            });\n            if (data.success) {\n                // Logout after password change as all sessions are invalidated\n                // await logout();\n                setUser((prevUser)=>prevUser ? {\n                        ...prevUser,\n                        password: newPassword\n                    } : null);\n            }\n        } catch (error) {\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Failed to update password');\n            } else {\n                setError('Failed to update password');\n            }\n            throw error;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Change username function\n    const changeUsername = async (newUsername)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const { data } = await api.post('/auth/change-username', {\n                newUsername\n            });\n            if (data.success) {\n                // Update the user in state with new username\n                setUser((prevUser)=>prevUser ? {\n                        ...prevUser,\n                        username: newUsername\n                    } : null);\n            }\n        } catch (error) {\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Failed to update username');\n            } else {\n                setError('Failed to update username');\n            }\n            throw error;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            isLoading,\n            isAuthenticated: !!user,\n            login,\n            register,\n            logout,\n            verifySession,\n            error,\n            changeEmail,\n            changePassword,\n            changeUsername\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\todor\\\\Coding_Projects\\\\Websites\\\\WEB_APP\\\\WEALTH_ARC_v1\\\\frontend\\\\src\\\\contexts\\\\AuthContext.tsx\",\n        lineNumber: 410,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"Zq89/X6aCvN7RwTmwGwoPjWf5jA=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\n// Custom hook for using auth context\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQ3JDO0FBQ0w7QUF3QjVDLGlCQUFpQjtBQUNqQixNQUFNUSw0QkFBY1Asb0RBQWFBLENBQThCUTtBQUUvRCxlQUFlO0FBQ2YsTUFBTUMsTUFBTUosNkNBQUtBLENBQUNLLE1BQU0sQ0FBQztJQUN2QkMsU0FBU0MsMkJBQStCO0lBQ3hDRyxpQkFBaUI7QUFDbkI7QUFFQSxnQ0FBZ0M7QUFDaENOLElBQUlPLFlBQVksQ0FBQ0MsUUFBUSxDQUFDQyxHQUFHLENBQzNCLENBQUNELFdBQWFBLFVBQ2QsT0FBT0U7UUFJa0JDLHNCQUNEQSx1QkFDQUEsdUJBR2xCRDtJQVJKLE1BQU1DLGtCQUFrQkQsTUFBTUUsTUFBTTtJQUVwQyx5REFBeUQ7SUFDekQsTUFBTUMsaUJBQWlCRixFQUFBQSx1QkFBQUEsZ0JBQWdCRyxHQUFHLGNBQW5CSCwyQ0FBQUEscUJBQXFCSSxRQUFRLENBQUMscUJBQy9CSix3QkFBQUEsZ0JBQWdCRyxHQUFHLGNBQW5CSCw0Q0FBQUEsc0JBQXFCSSxRQUFRLENBQUMsd0JBQzlCSix3QkFBQUEsZ0JBQWdCRyxHQUFHLGNBQW5CSCw0Q0FBQUEsc0JBQXFCSSxRQUFRLENBQUM7SUFFcEQsd0ZBQXdGO0lBQ3hGLElBQUlMLEVBQUFBLGtCQUFBQSxNQUFNRixRQUFRLGNBQWRFLHNDQUFBQSxnQkFBZ0JNLE1BQU0sTUFBSyxPQUFPLENBQUNMLGdCQUFnQk0sTUFBTSxJQUFJLENBQUNKLGdCQUFnQjtRQUNoRkYsZ0JBQWdCTSxNQUFNLEdBQUc7UUFFekIsSUFBSTtZQUNGLCtDQUErQztZQUMvQ0MsT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEdBQUc7WUFDdkIsT0FBT0MsUUFBUUMsTUFBTSxDQUFDWjtRQUN4QixFQUFFLE9BQU9hLGNBQWM7WUFDckJDLGFBQWFDLFVBQVUsQ0FBQztZQUN4QkQsYUFBYUMsVUFBVSxD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dkMsS0FBS0UsT0FBTyxFQUFFO2dCQUNoQiw2Q0FBNkM7Z0JBQzdDZixRQUFRK0MsQ0FBQUEsV0FBWUEsV0FBVzt3QkFBRSxHQUFHQSxRQUFRO3dCQUFFOUIsVUFBVW1DO29CQUFZLElBQUk7WUFDMUU7UUFDRixFQUFFLE9BQU92RSxPQUFnQjtZQUN2QixJQUFJQSxTQUFTLE9BQU9BLFVBQVUsWUFBWSxjQUFjQSxPQUFPO29CQUVwRDhDO2dCQURULE1BQU1BLGdCQUFnQjlDLE1BQU1GLFFBQVE7Z0JBQ3BDd0IsU0FBU3dCLENBQUFBLDBCQUFBQSxxQ0FBQUEsc0JBQUFBLGNBQWVkLElBQUksY0FBbkJjLDBDQUFBQSxvQkFBcUJDLE9BQU8sS0FBSTtZQUMzQyxPQUFPO2dCQUNMekIsU0FBUztZQUNYO1lBQ0EsTUFBTXRCO1FBQ1IsU0FBVTtZQUNScUIsYUFBYTtRQUNmO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ2pDLFlBQVlvRixRQUFRO1FBQ25CQyxPQUFPO1lBQ0x2RDtZQUNBRTtZQUNBc0QsaUJBQWlCLENBQUMsQ0FBQ3hEO1lBQ25CaUI7WUFDQWE7WUFDQUU7WUFDQVc7WUFDQTdEO1lBQ0FnRTtZQUNBRztZQUNBRztRQUNGO2tCQUVDckQ7Ozs7OztBQUdQLEVBQUU7R0F6V1dEOztRQUlJN0Isc0RBQVNBOzs7S0FKYjZCO0FBMldiLHFDQUFxQztBQUM5QixNQUFNMkQsVUFBVTs7SUFDckIsTUFBTUMsVUFBVTlGLGlEQUFVQSxDQUFDTTtJQUUzQixJQUFJd0YsWUFBWXZGLFdBQVc7UUFDekIsTUFBTSxJQUFJd0YsTUFBTTtJQUNsQjtJQUVBLE9BQU9EO0FBQ1QsRUFBRTtJQVJXRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29udGV4dHMvQXV0aENvbnRleHQudHN4PzFmYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBheGlvcywgeyBDYW5jZWxUb2tlblNvdXJjZSB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5cbi8vIFR5cGVzXG5pbnRlcmZhY2UgVXNlciB7XG4gIHVzZXJJZDogbnVtYmVyO1xuICB1c2VybmFtZTogc3RyaW5nO1xuICByb2xlOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUge1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW47XG4gIGxvZ2luOiAodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVnaXN0ZXI6ICh1c2VybmFtZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsb2dvdXQ6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHZlcmlmeVNlc3Npb246ICgpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBjaGFuZ2VFbWFpbDogKG5ld0VtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGNoYW5nZVBhc3N3b3JkOiAoY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsIG5ld1Bhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGNoYW5nZVVzZXJuYW1lOiAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbn1cblxuLy8gQ3JlYXRlIGNvbnRleHRcbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbi8vIEFQSSBpbnN0YW5jZVxuY29uc3QgYXBpID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCxcbiAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLCAvLyBJbXBvcnRhbnQgZm9yIGNvb2tpZXNcbn0pO1xuXG4vLyBJbnRlcmNlcHRvciBmb3IgdG9rZW4gcmVmcmVzaFxuYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXG4gIGFzeW5jIChlcnJvcikgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsUmVxdWVzdCA9IGVycm9yLmNvbmZpZztcbiAgICBcbiAgICAvLyBTa2lwIHJlZnJlc2ggdG9rZW4gZm9yIGF1dGggZW5kcG9pbnRzIHRvIHByZXZlbnQgbG9vcHNcbiAgICBjb25zdCBpc0F1dGhFbmRwb2ludCA9IG9yaWdpbmFsUmVxdWVzdC51cmw/LmluY2x1ZGVzKCcvYXV0aC9sb2dpbicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlcXVlc3QudXJsPy5pbmNsdWRlcygnL2F1dGgvcmVnaXN0ZXInKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlcXVlc3QudXJsPy5pbmNsdWRlcygnL2F1dGgvdmVyaWZ5LXNlc3Npb24nKTtcbiAgICBcbiAgICAvLyBJZiBlcnJvciBpcyA0MDEgYW5kIHdlIGhhdmVuJ3QgYWxyZWFkeSB0cmllZCB0byByZWZyZXNoIGFuZCBpdCdzIG5vdCBhbiBhdXRoIGVuZHBvaW50XG4gICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMSAmJiAhb3JpZ2luYWxSZXF1ZXN0Ll9yZXRyeSAmJiAhaXNBdXRoRW5kcG9pbnQpIHtcbiAgICAgIG9yaWdpbmFsUmVxdWVzdC5fcmV0cnkgPSB0cnVlO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBEb24ndCB0cnkgdG8gcmVmcmVzaCBoZXJlIC0gcmVkaXJlY3QgaW5zdGVhZFxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvYXV0aC9sb2dpbj9zZXNzaW9uPWV4cGlyZWQnO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfSBjYXRjaCAocmVmcmVzaEVycm9yKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhY2Nlc3NUb2tlbicpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncmVmcmVzaFRva2VuJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWZyZXNoRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG4pO1xuXG4vLyBQcm92aWRlciBjb21wb25lbnRcbmV4cG9ydCBjb25zdCBBdXRoUHJvdmlkZXI6IFJlYWN0LkZDPHtjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgXG4gIGNvbnN0IGNoZWNrU2Vzc2lvbkNhbmNlbFNvdXJjZSA9IHVzZVJlZjxDYW5jZWxUb2tlblNvdXJjZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCByZW5ld1Nlc3Npb25DYW5jZWxTb3VyY2UgPSB1c2VSZWY8Q2FuY2VsVG9rZW5Tb3VyY2UgfCBudWxsPihudWxsKTtcbiAgXG4gIC8vIENoZWNrIGlmIHVzZXIgaXMgYXV0aGVudGljYXRlZCBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNoZWNrQXV0aCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgICBcbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICBhcGkuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQoJy9hdXRoL21lJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgc2V0VXNlcihkYXRhLmRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWNjZXNzVG9rZW4nKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoVG9rZW4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfTtcbiAgICBcbiAgICBjaGVja0F1dGgoKTtcbiAgfSwgW10pO1xuICBcbiAgLy8gTG9naW4gZnVuY3Rpb25cbiAgY29uc3QgbG9naW4gPSBhc3luYyAodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQWRkIG1vcmUgbG9nZ2luZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyBsb2dpbiB3aXRoOicsIHsgdXNlcm5hbWUgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL2xvZ2luJywgeyB1c2VybmFtZSwgcGFzc3dvcmQgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdMb2dpbiByZXNwb25zZTonLCBkYXRhKTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAvLyBTdG9yZSB0b2tlbnMgaW4gbG9jYWxTdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhY2Nlc3NUb2tlbicsIGRhdGEuZGF0YS50b2tlbnMuYWNjZXNzVG9rZW4pO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmVmcmVzaFRva2VuJywgZGF0YS5kYXRhLnRva2Vucy5yZWZyZXNoVG9rZW4pO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVzZXIgZnJvbSByZXNwb25zZSBkYXRhXG4gICAgICAgIHNldFVzZXIoZGF0YS5kYXRhLnVzZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGF1dGggaGVhZGVyIGZvciBmdXR1cmUgcmVxdWVzdHNcbiAgICAgICAgYXBpLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7ZGF0YS5kYXRhLnRva2Vucy5hY2Nlc3NUb2tlbn1gO1xuICAgICAgICBcbiAgICAgICAgLy8gTmF2aWdhdGUgdG8gZGFzaGJvYXJkXG4gICAgICAgIHJvdXRlci5wdXNoKCcvZGFzaGJvYXJkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvZ2luIGVycm9yOicsIGVycm9yKTtcbiAgICAgIC8vIFR5cGUgZ3VhcmQgZm9yIGVycm9yIG9iamVjdFxuICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgJ3Jlc3BvbnNlJyBpbiBlcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2UgYXMgYW55O1xuICAgICAgICBzZXRFcnJvcihlcnJvclJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8ICdMb2dpbiBmYWlsZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEVycm9yKCdMb2dpbiBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBSZWdpc3RlciBmdW5jdGlvblxuICBjb25zdCByZWdpc3RlciA9IGFzeW5jICh1c2VybmFtZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9yZWdpc3RlcicsIHsgdXNlcm5hbWUsIGVtYWlsLCBwYXNzd29yZCB9KTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAvLyBTdG9yZSB0b2tlbnMgaW4gbG9jYWxTdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhY2Nlc3NUb2tlbicsIGRhdGEuZGF0YS50b2tlbnMuYWNjZXNzVG9rZW4pO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmVmcmVzaFRva2VuJywgZGF0YS5kYXRhLnRva2Vucy5yZWZyZXNoVG9rZW4pO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVzZXIgZnJvbSByZXNwb25zZSBkYXRhXG4gICAgICAgIHNldFVzZXIoZGF0YS5kYXRhLnVzZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGF1dGggaGVhZGVyIGZvciBmdXR1cmUgcmVxdWVzdHNcbiAgICAgICAgYXBpLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7ZGF0YS5kYXRhLnRva2Vucy5hY2Nlc3NUb2tlbn1gO1xuICAgICAgICBcbiAgICAgICAgLy8gTmF2aWdhdGUgdG8gZGFzaGJvYXJkXG4gICAgICAgIHJvdXRlci5wdXNoKCcvZGFzaGJvYXJkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgIC8vIFR5cGUgZ3VhcmQgZm9yIGVycm9yIG9iamVjdFxuICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgJ3Jlc3BvbnNlJyBpbiBlcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2UgYXMgYW55O1xuICAgICAgICBzZXRFcnJvcihlcnJvclJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8ICdSZWdpc3RyYXRpb24gZmFpbGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRFcnJvcignUmVnaXN0cmF0aW9uIGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIExvZ291dCBmdW5jdGlvblxuICBjb25zdCBsb2dvdXQgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdGhlIHJlZnJlc2ggdG9rZW4gZnJvbSBsb2NhbCBzdG9yYWdlXG4gICAgICBjb25zdCByZWZyZXNoVG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncmVmcmVzaFRva2VuJyk7XG4gICAgICBcbiAgICAgIGlmIChyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgLy8gU2VuZCB0aGUgcmVmcmVzaCB0b2tlbiB3aXRoIHRoZSBsb2dvdXQgcmVxdWVzdFxuICAgICAgICBhd2FpdCBhcGkucG9zdCgnL2F1dGgvbG9nb3V0JywgeyByZWZyZXNoVG9rZW4gfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHRva2VucyBmcm9tIHN0b3JhZ2VcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhY2Nlc3NUb2tlbicpO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciB1c2VyIHN0YXRlXG4gICAgICBzZXRVc2VyKG51bGwpO1xuICAgICAgXG4gICAgICAvLyBSZWRpcmVjdCB0byBsb2dpbiBwYWdlXG4gICAgICByb3V0ZXIucHVzaCgnL2F1dGgvbG9naW4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTG9nb3V0IGVycm9yOicsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBBZGQgdGhlc2UgbmV3IGZ1bmN0aW9ucyB0byBjaGVjayBhbmQgcmVuZXcgc2Vzc2lvblxuICBjb25zdCBjaGVja1Nlc3Npb24gPSBhc3luYyAocmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2FuY2VsIGFueSBwcmV2aW91cyByZXF1ZXN0XG4gICAgICBpZiAoY2hlY2tTZXNzaW9uQ2FuY2VsU291cmNlLmN1cnJlbnQpIHtcbiAgICAgICAgY2hlY2tTZXNzaW9uQ2FuY2VsU291cmNlLmN1cnJlbnQuY2FuY2VsKCdPcGVyYXRpb24gY2FuY2VsZWQgZHVlIHRvIG5ldyByZXF1ZXN0LicpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgY2FuY2VsIHRva2VuXG4gICAgICBjaGVja1Nlc3Npb25DYW5jZWxTb3VyY2UuY3VycmVudCA9IGF4aW9zLkNhbmNlbFRva2VuLnNvdXJjZSgpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgc2Vzc2lvbiB2YWxpZGl0eScpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvY2hlY2stc2Vzc2lvbicsIFxuICAgICAgICB7IHJlZnJlc2hUb2tlbiB9LCBcbiAgICAgICAgeyBjYW5jZWxUb2tlbjogY2hlY2tTZXNzaW9uQ2FuY2VsU291cmNlLmN1cnJlbnQudG9rZW4gfVxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnN1Y2Nlc3M7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChheGlvcy5pc0NhbmNlbChlcnJvcikpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlcXVlc3QgY2FuY2VsZWQ6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlbmV3U2Vzc2lvbiA9IGFzeW5jIChyZWZyZXNoVG9rZW46IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDYW5jZWwgYW55IHByZXZpb3VzIHJlcXVlc3RcbiAgICAgIGlmIChyZW5ld1Nlc3Npb25DYW5jZWxTb3VyY2UuY3VycmVudCkge1xuICAgICAgICByZW5ld1Nlc3Npb25DYW5jZWxTb3VyY2UuY3VycmVudC5jYW5jZWwoJ09wZXJhdGlvbiBjYW5jZWxlZCBkdWUgdG8gbmV3IHJlcXVlc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBjYW5jZWwgdG9rZW5cbiAgICAgIHJlbmV3U2Vzc2lvbkNhbmNlbFNvdXJjZS5jdXJyZW50ID0gYXhpb3MuQ2FuY2VsVG9rZW4uc291cmNlKCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdSZW5ld2luZyBzZXNzaW9uJyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9yZW5ldy1zZXNzaW9uJywgXG4gICAgICAgIHsgcmVmcmVzaFRva2VuIH0sIFxuICAgICAgICB7IGNhbmNlbFRva2VuOiByZW5ld1Nlc3Npb25DYW5jZWxTb3VyY2UuY3VycmVudC50b2tlbiB9XG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0b2tlbnNcbiAgICAgICAgY29uc3QgbmV3QWNjZXNzVG9rZW4gPSByZXNwb25zZS5kYXRhLmRhdGEuYWNjZXNzVG9rZW47XG4gICAgICAgIGNvbnN0IG5ld1JlZnJlc2hUb2tlbiA9IHJlc3BvbnNlLmRhdGEuZGF0YS5yZWZyZXNoVG9rZW47XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnU2Vzc2lvbiByZW5ld2VkIHN1Y2Nlc3NmdWxseSwgcmVjZWl2ZWQgbmV3IHRva2VucycpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYWNjZXNzVG9rZW4nLCBuZXdBY2Nlc3NUb2tlbik7XG4gICAgICAgIGlmIChuZXdSZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncmVmcmVzaFRva2VuJywgbmV3UmVmcmVzaFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAgICAgIGFwaS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke25ld0FjY2Vzc1Rva2VufWA7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoYXhpb3MuaXNDYW5jZWwoZXJyb3IpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IGNhbmNlbGVkOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiByZW5ld2FsIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlcGxhY2UgdGhlIGN1cnJlbnQgdmVyaWZ5U2Vzc2lvbiB3aXRoIHRoaXMgbW9kdWxhciBhcHByb2FjaFxuICBjb25zdCB2ZXJpZnlTZXNzaW9uID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHNlc3Npb24gdmVyaWZpY2F0aW9uIHByb2Nlc3MnKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHJlZnJlc2ggdG9rZW5cbiAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdyZWZyZXNoVG9rZW4nKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTm8gcmVmcmVzaCB0b2tlbiBhdmFpbGFibGUnKTtcbiAgICAgICAgYXdhaXQgbG9nb3V0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmlyc3QganVzdCBjaGVjayBpZiBzZXNzaW9uIGlzIHZhbGlkXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgY2hlY2tTZXNzaW9uKHJlZnJlc2hUb2tlbik7XG4gICAgICBcbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnU2Vzc2lvbiBpbnZhbGlkLCBsb2dnaW5nIG91dCcpO1xuICAgICAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIGxvZ291dCBmdW5jdGlvbiB0aGF0IHdlIGtub3cgd29ya3NcbiAgICAgICAgYXdhaXQgbG9nb3V0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgdmFsaWQsIHJlbmV3IHRoZSBzZXNzaW9uXG4gICAgICBjb25zdCByZW5ld2VkID0gYXdhaXQgcmVuZXdTZXNzaW9uKHJlZnJlc2hUb2tlbik7XG4gICAgICBcbiAgICAgIGlmICghcmVuZXdlZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnU2Vzc2lvbiByZW5ld2FsIGZhaWxlZCwgbG9nZ2luZyBvdXQnKTtcbiAgICAgICAgYXdhaXQgbG9nb3V0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIHZlcmlmaWNhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGFuZ2UgZW1haWwgZnVuY3Rpb25cbiAgY29uc3QgY2hhbmdlRW1haWwgPSBhc3luYyAobmV3RW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvY2hhbmdlLWVtYWlsJywgeyBcbiAgICAgICAgbmV3RW1haWwsIFxuICAgICAgICBwYXNzd29yZCBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdXNlciBpbiBzdGF0ZSB3aXRoIG5ldyBlbWFpbFxuICAgICAgICBzZXRVc2VyKHByZXZVc2VyID0+IHByZXZVc2VyID8geyAuLi5wcmV2VXNlciwgZW1haWw6IG5ld0VtYWlsIH0gOiBudWxsKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgJ3Jlc3BvbnNlJyBpbiBlcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2UgYXMgYW55O1xuICAgICAgICBzZXRFcnJvcihlcnJvclJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIGVtYWlsJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBlbWFpbCcpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoYW5nZSBwYXNzd29yZCBmdW5jdGlvblxuICBjb25zdCBjaGFuZ2VQYXNzd29yZCA9IGFzeW5jIChjdXJyZW50UGFzc3dvcmQ6IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvY2hhbmdlLXBhc3N3b3JkJywgeyBcbiAgICAgICAgY3VycmVudFBhc3N3b3JkLCBcbiAgICAgICAgbmV3UGFzc3dvcmQgXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAvLyBMb2dvdXQgYWZ0ZXIgcGFzc3dvcmQgY2hhbmdlIGFzIGFsbCBzZXNzaW9ucyBhcmUgaW52YWxpZGF0ZWRcbiAgICAgICAgLy8gYXdhaXQgbG9nb3V0KCk7XG4gICAgICAgIHNldFVzZXIocHJldlVzZXIgPT4gcHJldlVzZXIgPyB7IC4uLnByZXZVc2VyLCBwYXNzd29yZDogbmV3UGFzc3dvcmR9IDogbnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdyZXNwb25zZScgaW4gZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlIGFzIGFueTtcbiAgICAgICAgc2V0RXJyb3IoZXJyb3JSZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBwYXNzd29yZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgcGFzc3dvcmQnKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGFuZ2UgdXNlcm5hbWUgZnVuY3Rpb25cbiAgY29uc3QgY2hhbmdlVXNlcm5hbWUgPSBhc3luYyAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvY2hhbmdlLXVzZXJuYW1lJywgeyBcbiAgICAgICAgbmV3VXNlcm5hbWUgXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHVzZXIgaW4gc3RhdGUgd2l0aCBuZXcgdXNlcm5hbWVcbiAgICAgICAgc2V0VXNlcihwcmV2VXNlciA9PiBwcmV2VXNlciA/IHsgLi4ucHJldlVzZXIsIHVzZXJuYW1lOiBuZXdVc2VybmFtZSB9IDogbnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdyZXNwb25zZScgaW4gZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlIGFzIGFueTtcbiAgICAgICAgc2V0RXJyb3IoZXJyb3JSZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwZGF0ZSB1c2VybmFtZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgdXNlcm5hbWUnKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgXG4gIHJldHVybiAoXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICB1c2VyLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogISF1c2VyLFxuICAgICAgICBsb2dpbixcbiAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgIGxvZ291dCxcbiAgICAgICAgdmVyaWZ5U2Vzc2lvbixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGNoYW5nZUVtYWlsLFxuICAgICAgICBjaGFuZ2VQYXNzd29yZCxcbiAgICAgICAgY2hhbmdlVXNlcm5hbWUsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuLy8gQ3VzdG9tIGhvb2sgZm9yIHVzaW5nIGF1dGggY29udGV4dFxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcbiAgXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUF1dGggbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBBdXRoUHJvdmlkZXInKTtcbiAgfVxuICBcbiAgcmV0dXJuIGNvbnRleHQ7XG59OyAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiYXhpb3MiLCJ1c2VSb3V0ZXIiLCJBdXRoQ29udGV4dCIsInVuZGVmaW5lZCIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIndpdGhDcmVkZW50aWFscyIsImludGVyY2VwdG9ycyIsInJlc3BvbnNlIiwidXNlIiwiZXJyb3IiLCJvcmlnaW5hbFJlcXVlc3QiLCJjb25maWciLCJpc0F1dGhFbmRwb2ludCIsInVybCIsImluY2x1ZGVzIiwic3RhdHVzIiwiX3JldHJ5Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiUHJvbWlzZSIsInJlamVjdCIsInJlZnJlc2hFcnJvciIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic2V0RXJyb3IiLCJyb3V0ZXIiLCJjaGVja1Nlc3Npb25DYW5jZWxTb3VyY2UiLCJyZW5ld1Nlc3Npb25DYW5jZWxTb3VyY2UiLCJjaGVja0F1dGgiLCJ0b2tlbiIsImdldEl0ZW0iLCJkZWZhdWx0cyIsImhlYWRlcnMiLCJjb21tb24iLCJkYXRhIiwiZ2V0Iiwic3VjY2VzcyIsImxvZ2luIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImNvbnNvbGUiLCJsb2ciLCJwb3N0Iiwic2V0SXRlbSIsInRva2VucyIsImFjY2Vzc1Rva2VuIiwicmVmcmVzaFRva2VuIiwicHVzaCIsImVycm9yUmVzcG9uc2UiLCJtZXNzYWdlIiwicmVnaXN0ZXIiLCJlbWFpbCIsImxvZ291dCIsImNoZWNrU2Vzc2lvbiIsImN1cnJlbnQiLCJjYW5jZWwiLCJDYW5jZWxUb2tlbiIsInNvdXJjZSIsImNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJyZW5ld1Nlc3Npb24iLCJuZXdBY2Nlc3NUb2tlbiIsIm5ld1JlZnJlc2hUb2tlbiIsInZlcmlmeVNlc3Npb24iLCJpc1ZhbGlkIiwicmVuZXdlZCIsImNoYW5nZUVtYWlsIiwibmV3RW1haWwiLCJwcmV2VXNlciIsImNoYW5nZVBhc3N3b3JkIiwiY3VycmVudFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJjaGFuZ2VVc2VybmFtZSIsIm5ld1VzZXJuYW1lIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImlzQXV0aGVudGljYXRlZCIsInVzZUF1dGgiLCJjb250ZXh0IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/AuthContext.tsx\n"));

/***/ })

});