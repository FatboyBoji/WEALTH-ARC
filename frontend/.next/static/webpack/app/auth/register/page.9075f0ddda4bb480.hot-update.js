"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/auth/register/page",{

/***/ "(app-pages-browser)/./src/contexts/AuthContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/AuthContext.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n// Create context\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// API instance\nconst api = axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].create({\n    baseURL: \"http://localhost:3001/api\",\n    withCredentials: true\n});\n// Interceptor for token refresh\napi.interceptors.response.use((response)=>response, async (error)=>{\n    var _originalRequest_url, _originalRequest_url1, _originalRequest_url2, _error_response;\n    const originalRequest = error.config;\n    // Skip refresh token for auth endpoints to prevent loops\n    const isAuthEndpoint = ((_originalRequest_url = originalRequest.url) === null || _originalRequest_url === void 0 ? void 0 : _originalRequest_url.includes('/auth/login')) || ((_originalRequest_url1 = originalRequest.url) === null || _originalRequest_url1 === void 0 ? void 0 : _originalRequest_url1.includes('/auth/register')) || ((_originalRequest_url2 = originalRequest.url) === null || _originalRequest_url2 === void 0 ? void 0 : _originalRequest_url2.includes('/auth/verify-session'));\n    // If error is 401 and we haven't already tried to refresh and it's not an auth endpoint\n    if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401 && !originalRequest._retry && !isAuthEndpoint) {\n        originalRequest._retry = true;\n        try {\n            // Don't try to refresh here - redirect instead\n            window.location.href = '/auth/login?session=expired';\n            return Promise.reject(error);\n        } catch (refreshError) {\n            localStorage.removeItem('accessToken');\n            localStorage.removeItem('refreshToken');\n            return Promise.reject(refreshError);\n        }\n    }\n    return Promise.reject(error);\n});\n// Provider component\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const checkSessionCancelSource = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const renewSessionCancelSource = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Check if user is authenticated on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const checkAuth = async ()=>{\n            const token = localStorage.getItem('accessToken');\n            if (token) {\n                api.defaults.headers.common['Authorization'] = \"Bearer \".concat(token);\n                try {\n                    const { data } = await api.get('/auth/me');\n                    if (data.success) {\n                        setUser(data.data);\n                    } else {\n                        localStorage.removeItem('accessToken');\n                        localStorage.removeItem('refreshToken');\n                    }\n                } catch (error) {\n                    localStorage.removeItem('accessToken');\n                    localStorage.removeItem('refreshToken');\n                }\n            }\n            setIsLoading(false);\n        };\n        checkAuth();\n    }, []);\n    // Login function\n    const login = async (username, password)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            // Add more logging for debugging\n            console.log('Attempting login with:', {\n                username\n            });\n            const { data } = await api.post('/auth/login', {\n                username,\n                password\n            });\n            console.log('Login response:', data);\n            if (data.success) {\n                // Store tokens in localStorage\n                localStorage.setItem('accessToken', data.data.tokens.accessToken);\n                localStorage.setItem('refreshToken', data.data.tokens.refreshToken);\n                // Set user from response data\n                setUser(data.data.user);\n                // Set auth header for future requests\n                api.defaults.headers.common['Authorization'] = \"Bearer \".concat(data.data.tokens.accessToken);\n                // Navigate to dashboard\n                router.push('/dashboard');\n            }\n        } catch (error) {\n            console.error('Login error:', error);\n            // Type guard for error object\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Login failed');\n            } else {\n                setError('Login failed');\n            }\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Register function\n    const register = async (username, email, password)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const { data } = await api.post('/auth/register', {\n                username,\n                email,\n                password\n            });\n            if (data.success) {\n                // Store tokens in localStorage\n                localStorage.setItem('accessToken', data.data.tokens.accessToken);\n                localStorage.setItem('refreshToken', data.data.tokens.refreshToken);\n                // Set user from response data\n                setUser(data.data.user);\n                // Set auth header for future requests\n                api.defaults.headers.common['Authorization'] = \"Bearer \".concat(data.data.tokens.accessToken);\n                // Navigate to dashboard\n                router.push('/dashboard');\n            }\n        } catch (error) {\n            // Type guard for error object\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Registration failed');\n            } else {\n                setError('Registration failed');\n            }\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Logout function\n    const logout = async ()=>{\n        setIsLoading(true);\n        try {\n            // Get the refresh token from local storage\n            const refreshToken = localStorage.getItem('refreshToken');\n            if (refreshToken) {\n                // Send the refresh token with the logout request\n                await api.post('/auth/logout', {\n                    refreshToken\n                });\n            }\n            // Clear tokens from storage\n            localStorage.removeItem('accessToken');\n            localStorage.removeItem('refreshToken');\n            // Clear user state\n            setUser(null);\n            // Redirect to login page\n            router.push('/auth/login');\n        } catch (error) {\n            console.error('Logout error:', error);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Add these new functions to check and renew session\n    const checkSession = async (refreshToken)=>{\n        try {\n            // Cancel any previous request\n            if (checkSessionCancelSource.current) {\n                checkSessionCancelSource.current.cancel('Operation canceled due to new request.');\n            }\n            // Create a new cancel token\n            checkSessionCancelSource.current = axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CancelToken.source();\n            console.log('Checking session validity');\n            const response = await api.post('/auth/check-session', {\n                refreshToken\n            }, {\n                cancelToken: checkSessionCancelSource.current.token\n            });\n            return response.data.success;\n        } catch (error) {\n            if (axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isCancel(error)) {\n                console.log('Request canceled:', error.message);\n            } else {\n                console.error('Session check failed:', error);\n            }\n            return false;\n        }\n    };\n    const renewSession = async (refreshToken)=>{\n        try {\n            // Cancel any previous request\n            if (renewSessionCancelSource.current) {\n                renewSessionCancelSource.current.cancel('Operation canceled due to new request.');\n            }\n            // Create a new cancel token\n            renewSessionCancelSource.current = axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].CancelToken.source();\n            console.log('Renewing session');\n            const response = await api.post('/auth/renew-session', {\n                refreshToken\n            }, {\n                cancelToken: renewSessionCancelSource.current.token\n            });\n            if (response.data.success) {\n                // Update tokens\n                const newAccessToken = response.data.data.accessToken;\n                const newRefreshToken = response.data.data.refreshToken;\n                console.log('Session renewed successfully, received new tokens');\n                localStorage.setItem('accessToken', newAccessToken);\n                if (newRefreshToken) {\n                    localStorage.setItem('refreshToken', newRefreshToken);\n                }\n                // Update authorization header\n                api.defaults.headers.common['Authorization'] = \"Bearer \".concat(newAccessToken);\n                return true;\n            }\n            return false;\n        } catch (error) {\n            if (axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isCancel(error)) {\n                console.log('Request canceled:', error.message);\n            } else {\n                console.error('Session renewal failed:', error);\n            }\n            return false;\n        }\n    };\n    // Replace the current verifySession with this modular approach\n    const verifySession = async ()=>{\n        setIsLoading(true);\n        try {\n            console.log('Starting session verification process');\n            // Get refresh token\n            const refreshToken = localStorage.getItem('refreshToken');\n            if (!refreshToken) {\n                console.error('No refresh token available');\n                await logout();\n                return false;\n            }\n            // First just check if session is valid\n            const isValid = await checkSession(refreshToken);\n            if (!isValid) {\n                console.log('Session invalid, logging out');\n                // Use the existing logout function that we know works\n                await logout();\n                return false;\n            }\n            // If valid, renew the session\n            const renewed = await renewSession(refreshToken);\n            if (!renewed) {\n                console.log('Session renewal failed, logging out');\n                await logout();\n                return false;\n            }\n            setIsLoading(false);\n            return true;\n        } catch (error) {\n            console.error('Session verification error:', error);\n            setIsLoading(false);\n            return false;\n        }\n    };\n    // Change email function\n    const changeEmail = async (newEmail, password)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const { data } = await api.post('/auth/change-email', {\n                newEmail,\n                password\n            });\n            if (data.success) {\n                // Update the user in state with new email\n                setUser((prevUser)=>prevUser ? {\n                        ...prevUser,\n                        email: newEmail\n                    } : null);\n            }\n        } catch (error) {\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Failed to update email');\n            } else {\n                setError('Failed to update email');\n            }\n            throw error;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Change password function\n    const changePassword = async (currentPassword, newPassword)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const { data } = await api.post('/auth/change-password', {\n                currentPassword,\n                newPassword\n            });\n            if (data.success) {\n            // Logout after password change as all sessions are invalidated\n            // await logout();\n            // setUser(prevUser => prevUser ? { ...prevUser, currentPassword: newPassword} : null);\n            }\n        } catch (error) {\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Failed to update password');\n            } else {\n                setError('Failed to update password');\n            }\n            throw error;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Change username function\n    const changeUsername = async (newUsername)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const { data } = await api.post('/auth/change-username', {\n                newUsername\n            });\n            if (data.success) {\n                // Update the user in state with new username\n                setUser((prevUser)=>prevUser ? {\n                        ...prevUser,\n                        username: newUsername\n                    } : null);\n            }\n        } catch (error) {\n            if (error && typeof error === 'object' && 'response' in error) {\n                var _errorResponse_data;\n                const errorResponse = error.response;\n                setError((errorResponse === null || errorResponse === void 0 ? void 0 : (_errorResponse_data = errorResponse.data) === null || _errorResponse_data === void 0 ? void 0 : _errorResponse_data.message) || 'Failed to update username');\n            } else {\n                setError('Failed to update username');\n            }\n            throw error;\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            isLoading,\n            isAuthenticated: !!user,\n            login,\n            register,\n            logout,\n            verifySession,\n            error,\n            changeEmail,\n            changePassword,\n            changeUsername\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\todor\\\\Coding_Projects\\\\Websites\\\\WEB_APP\\\\WEALTH_ARC_v1\\\\frontend\\\\src\\\\contexts\\\\AuthContext.tsx\",\n        lineNumber: 410,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"Zq89/X6aCvN7RwTmwGwoPjWf5jA=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthProvider;\n// Custom hook for using auth context\nconst useAuth = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n};\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9BdXRoQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQ3JDO0FBQ0w7QUF3QjVDLGlCQUFpQjtBQUNqQixNQUFNUSw0QkFBY1Asb0RBQWFBLENBQThCUTtBQUUvRCxlQUFlO0FBQ2YsTUFBTUMsTUFBTUosNkNBQUtBLENBQUNLLE1BQU0sQ0FBQztJQUN2QkMsU0FBU0MsMkJBQStCO0lBQ3hDRyxpQkFBaUI7QUFDbkI7QUFFQSxnQ0FBZ0M7QUFDaENOLElBQUlPLFlBQVksQ0FBQ0MsUUFBUSxDQUFDQyxHQUFHLENBQzNCLENBQUNELFdBQWFBLFVBQ2QsT0FBT0U7UUFJa0JDLHNCQUNEQSx1QkFDQUEsdUJBR2xCRDtJQVJKLE1BQU1DLGtCQUFrQkQsTUFBTUUsTUFBTTtJQUVwQyx5REFBeUQ7SUFDekQsTUFBTUMsaUJBQWlCRixFQUFBQSx1QkFBQUEsZ0JBQWdCRyxHQUFHLGNBQW5CSCwyQ0FBQUEscUJBQXFCSSxRQUFRLENBQUMscUJBQy9CSix3QkFBQUEsZ0JBQWdCRyxHQUFHLGNBQW5CSCw0Q0FBQUEsc0JBQXFCSSxRQUFRLENBQUMsd0JBQzlCSix3QkFBQUEsZ0JBQWdCRyxHQUFHLGNBQW5CSCw0Q0FBQUEsc0JBQXFCSSxRQUFRLENBQUM7SUFFcEQsd0ZBQXdGO0lBQ3hGLElBQUlMLEVBQUFBLGtCQUFBQSxNQUFNRixRQUFRLGNBQWRFLHNDQUFBQSxnQkFBZ0JNLE1BQU0sTUFBSyxPQUFPLENBQUNMLGdCQUFnQk0sTUFBTSxJQUFJLENBQUNKLGdCQUFnQjtRQUNoRkYsZ0JBQWdCTSxNQUFNLEdBQUc7UUFFekIsSUFBSTtZQUNGLCtDQUErQztZQUMvQ0MsT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEdBQUc7WUFDdkIsT0FBT0MsUUFBUUMsTUFBTSxDQUFDWjtRQUN4QixFQUFFLE9BQU9hLGNBQWM7WUFDckJDLGFBQWFDLFVBQVUsQ0FBQztZQUN4QkQsYUFBYUMsVUFBVSxD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O3dCQUFFLEdBQUdBLFFBQVE7d0JBQUU5QixVQUFVbUM7b0JBQVksSUFBSTtZQUMxRTtRQUNGLEVBQUUsT0FBT3ZFLE9BQWdCO1lBQ3ZCLElBQUlBLFNBQVMsT0FBT0EsVUFBVSxZQUFZLGNBQWNBLE9BQU87b0JBRXBEOEM7Z0JBRFQsTUFBTUEsZ0JBQWdCOUMsTUFBTUYsUUFBUTtnQkFDcEN3QixTQUFTd0IsQ0FBQUEsMEJBQUFBLHFDQUFBQSxzQkFBQUEsY0FBZWQsSUFBSSxjQUFuQmMsMENBQUFBLG9CQUFxQkMsT0FBTyxLQUFJO1lBQzNDLE9BQU87Z0JBQ0x6QixTQUFTO1lBQ1g7WUFDQSxNQUFNdEI7UUFDUixTQUFVO1lBQ1JxQixhQUFhO1FBQ2Y7SUFDRjtJQUVBLHFCQUNFLDhEQUFDakMsWUFBWW9GLFFBQVE7UUFDbkJDLE9BQU87WUFDTHZEO1lBQ0FFO1lBQ0FzRCxpQkFBaUIsQ0FBQyxDQUFDeEQ7WUFDbkJpQjtZQUNBYTtZQUNBRTtZQUNBVztZQUNBN0Q7WUFDQWdFO1lBQ0FHO1lBQ0FHO1FBQ0Y7a0JBRUNyRDs7Ozs7O0FBR1AsRUFBRTtHQXpXV0Q7O1FBSUk3QixzREFBU0E7OztLQUpiNkI7QUEyV2IscUNBQXFDO0FBQzlCLE1BQU0yRCxVQUFVOztJQUNyQixNQUFNQyxVQUFVOUYsaURBQVVBLENBQUNNO0lBRTNCLElBQUl3RixZQUFZdkYsV0FBVztRQUN6QixNQUFNLElBQUl3RixNQUFNO0lBQ2xCO0lBRUEsT0FBT0Q7QUFDVCxFQUFFO0lBUldEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9BdXRoQ29udGV4dC50c3g/MWZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGF4aW9zLCB7IENhbmNlbFRva2VuU291cmNlIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcblxuLy8gVHlwZXNcbmludGVyZmFjZSBVc2VyIHtcbiAgdXNlcklkOiBudW1iZXI7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHJvbGU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEF1dGhDb250ZXh0VHlwZSB7XG4gIHVzZXI6IFVzZXIgfCBudWxsO1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhbjtcbiAgbG9naW46ICh1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZWdpc3RlcjogKHVzZXJuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGxvZ291dDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgdmVyaWZ5U2Vzc2lvbjogKCkgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIGNoYW5nZUVtYWlsOiAobmV3RW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgY2hhbmdlUGFzc3dvcmQ6IChjdXJyZW50UGFzc3dvcmQ6IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgY2hhbmdlVXNlcm5hbWU6IChuZXdVc2VybmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vLyBDcmVhdGUgY29udGV4dFxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1dGhDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuLy8gQVBJIGluc3RhbmNlXG5jb25zdCBhcGkgPSBheGlvcy5jcmVhdGUoe1xuICBiYXNlVVJMOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMLFxuICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsIC8vIEltcG9ydGFudCBmb3IgY29va2llc1xufSk7XG5cbi8vIEludGVyY2VwdG9yIGZvciB0b2tlbiByZWZyZXNoXG5hcGkuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcbiAgKHJlc3BvbnNlKSA9PiByZXNwb25zZSxcbiAgYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxSZXF1ZXN0ID0gZXJyb3IuY29uZmlnO1xuICAgIFxuICAgIC8vIFNraXAgcmVmcmVzaCB0b2tlbiBmb3IgYXV0aCBlbmRwb2ludHMgdG8gcHJldmVudCBsb29wc1xuICAgIGNvbnN0IGlzQXV0aEVuZHBvaW50ID0gb3JpZ2luYWxSZXF1ZXN0LnVybD8uaW5jbHVkZXMoJy9hdXRoL2xvZ2luJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUmVxdWVzdC51cmw/LmluY2x1ZGVzKCcvYXV0aC9yZWdpc3RlcicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUmVxdWVzdC51cmw/LmluY2x1ZGVzKCcvYXV0aC92ZXJpZnktc2Vzc2lvbicpO1xuICAgIFxuICAgIC8vIElmIGVycm9yIGlzIDQwMSBhbmQgd2UgaGF2ZW4ndCBhbHJlYWR5IHRyaWVkIHRvIHJlZnJlc2ggYW5kIGl0J3Mgbm90IGFuIGF1dGggZW5kcG9pbnRcbiAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDAxICYmICFvcmlnaW5hbFJlcXVlc3QuX3JldHJ5ICYmICFpc0F1dGhFbmRwb2ludCkge1xuICAgICAgb3JpZ2luYWxSZXF1ZXN0Ll9yZXRyeSA9IHRydWU7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIERvbid0IHRyeSB0byByZWZyZXNoIGhlcmUgLSByZWRpcmVjdCBpbnN0ZWFkXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9hdXRoL2xvZ2luP3Nlc3Npb249ZXhwaXJlZCc7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9IGNhdGNoIChyZWZyZXNoRXJyb3IpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdyZWZyZXNoVG9rZW4nKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlZnJlc2hFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH1cbik7XG5cbi8vIFByb3ZpZGVyIGNvbXBvbmVudFxuZXhwb3J0IGNvbnN0IEF1dGhQcm92aWRlcjogUmVhY3QuRkM8e2NoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGV9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBcbiAgY29uc3QgY2hlY2tTZXNzaW9uQ2FuY2VsU291cmNlID0gdXNlUmVmPENhbmNlbFRva2VuU291cmNlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlbmV3U2Vzc2lvbkNhbmNlbFNvdXJjZSA9IHVzZVJlZjxDYW5jZWxUb2tlblNvdXJjZSB8IG51bGw+KG51bGwpO1xuICBcbiAgLy8gQ2hlY2sgaWYgdXNlciBpcyBhdXRoZW50aWNhdGVkIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2hlY2tBdXRoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzVG9rZW4nKTtcbiAgICAgIFxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGFwaS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3Rva2VufWA7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLmdldCgnL2F1dGgvbWUnKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBzZXRVc2VyKGRhdGEuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhY2Nlc3NUb2tlbicpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYWNjZXNzVG9rZW4nKTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncmVmcmVzaFRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9O1xuICAgIFxuICAgIGNoZWNrQXV0aCgpO1xuICB9LCBbXSk7XG4gIFxuICAvLyBMb2dpbiBmdW5jdGlvblxuICBjb25zdCBsb2dpbiA9IGFzeW5jICh1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgbW9yZSBsb2dnaW5nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIGxvZ2luIHdpdGg6JywgeyB1c2VybmFtZSB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvbG9naW4nLCB7IHVzZXJuYW1lLCBwYXNzd29yZCB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0xvZ2luIHJlc3BvbnNlOicsIGRhdGEpO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIC8vIFN0b3JlIHRva2VucyBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FjY2Vzc1Rva2VuJywgZGF0YS5kYXRhLnRva2Vucy5hY2Nlc3NUb2tlbik7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyZWZyZXNoVG9rZW4nLCBkYXRhLmRhdGEudG9rZW5zLnJlZnJlc2hUb2tlbik7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdXNlciBmcm9tIHJlc3BvbnNlIGRhdGFcbiAgICAgICAgc2V0VXNlcihkYXRhLmRhdGEudXNlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgYXV0aCBoZWFkZXIgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICBhcGkuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHtkYXRhLmRhdGEudG9rZW5zLmFjY2Vzc1Rva2VufWA7XG4gICAgICAgIFxuICAgICAgICAvLyBOYXZpZ2F0ZSB0byBkYXNoYm9hcmRcbiAgICAgICAgcm91dGVyLnB1c2goJy9kYXNoYm9hcmQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgY29uc29sZS5lcnJvcignTG9naW4gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgLy8gVHlwZSBndWFyZCBmb3IgZXJyb3Igb2JqZWN0XG4gICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAncmVzcG9uc2UnIGluIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZSBhcyBhbnk7XG4gICAgICAgIHNldEVycm9yKGVycm9yUmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ0xvZ2luIGZhaWxlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoJ0xvZ2luIGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIFJlZ2lzdGVyIGZ1bmN0aW9uXG4gIGNvbnN0IHJlZ2lzdGVyID0gYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3JlZ2lzdGVyJywgeyB1c2VybmFtZSwgZW1haWwsIHBhc3N3b3JkIH0pO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIC8vIFN0b3JlIHRva2VucyBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FjY2Vzc1Rva2VuJywgZGF0YS5kYXRhLnRva2Vucy5hY2Nlc3NUb2tlbik7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyZWZyZXNoVG9rZW4nLCBkYXRhLmRhdGEudG9rZW5zLnJlZnJlc2hUb2tlbik7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdXNlciBmcm9tIHJlc3BvbnNlIGRhdGFcbiAgICAgICAgc2V0VXNlcihkYXRhLmRhdGEudXNlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgYXV0aCBoZWFkZXIgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICBhcGkuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ0F1dGhvcml6YXRpb24nXSA9IGBCZWFyZXIgJHtkYXRhLmRhdGEudG9rZW5zLmFjY2Vzc1Rva2VufWA7XG4gICAgICAgIFxuICAgICAgICAvLyBOYXZpZ2F0ZSB0byBkYXNoYm9hcmRcbiAgICAgICAgcm91dGVyLnB1c2goJy9kYXNoYm9hcmQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgLy8gVHlwZSBndWFyZCBmb3IgZXJyb3Igb2JqZWN0XG4gICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAncmVzcG9uc2UnIGluIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZSBhcyBhbnk7XG4gICAgICAgIHNldEVycm9yKGVycm9yUmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ1JlZ2lzdHJhdGlvbiBmYWlsZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEVycm9yKCdSZWdpc3RyYXRpb24gZmFpbGVkJyk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gTG9nb3V0IGZ1bmN0aW9uXG4gIGNvbnN0IGxvZ291dCA9IGFzeW5jICgpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCB0aGUgcmVmcmVzaCB0b2tlbiBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAgICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdyZWZyZXNoVG9rZW4nKTtcbiAgICAgIFxuICAgICAgaWYgKHJlZnJlc2hUb2tlbikge1xuICAgICAgICAvLyBTZW5kIHRoZSByZWZyZXNoIHRva2VuIHdpdGggdGhlIGxvZ291dCByZXF1ZXN0XG4gICAgICAgIGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9sb2dvdXQnLCB7IHJlZnJlc2hUb2tlbiB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgdG9rZW5zIGZyb20gc3RvcmFnZVxuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2FjY2Vzc1Rva2VuJyk7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncmVmcmVzaFRva2VuJyk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHVzZXIgc3RhdGVcbiAgICAgIHNldFVzZXIobnVsbCk7XG4gICAgICBcbiAgICAgIC8vIFJlZGlyZWN0IHRvIGxvZ2luIHBhZ2VcbiAgICAgIHJvdXRlci5wdXNoKCcvYXV0aC9sb2dpbicpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dvdXQgZXJyb3I6JywgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEFkZCB0aGVzZSBuZXcgZnVuY3Rpb25zIHRvIGNoZWNrIGFuZCByZW5ldyBzZXNzaW9uXG4gIGNvbnN0IGNoZWNrU2Vzc2lvbiA9IGFzeW5jIChyZWZyZXNoVG9rZW46IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDYW5jZWwgYW55IHByZXZpb3VzIHJlcXVlc3RcbiAgICAgIGlmIChjaGVja1Nlc3Npb25DYW5jZWxTb3VyY2UuY3VycmVudCkge1xuICAgICAgICBjaGVja1Nlc3Npb25DYW5jZWxTb3VyY2UuY3VycmVudC5jYW5jZWwoJ09wZXJhdGlvbiBjYW5jZWxlZCBkdWUgdG8gbmV3IHJlcXVlc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBjYW5jZWwgdG9rZW5cbiAgICAgIGNoZWNrU2Vzc2lvbkNhbmNlbFNvdXJjZS5jdXJyZW50ID0gYXhpb3MuQ2FuY2VsVG9rZW4uc291cmNlKCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBzZXNzaW9uIHZhbGlkaXR5Jyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9jaGVjay1zZXNzaW9uJywgXG4gICAgICAgIHsgcmVmcmVzaFRva2VuIH0sIFxuICAgICAgICB7IGNhbmNlbFRva2VuOiBjaGVja1Nlc3Npb25DYW5jZWxTb3VyY2UuY3VycmVudC50b2tlbiB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuc3VjY2VzcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGF4aW9zLmlzQ2FuY2VsKGVycm9yKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVxdWVzdCBjYW5jZWxlZDonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVuZXdTZXNzaW9uID0gYXN5bmMgKHJlZnJlc2hUb2tlbjogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENhbmNlbCBhbnkgcHJldmlvdXMgcmVxdWVzdFxuICAgICAgaWYgKHJlbmV3U2Vzc2lvbkNhbmNlbFNvdXJjZS5jdXJyZW50KSB7XG4gICAgICAgIHJlbmV3U2Vzc2lvbkNhbmNlbFNvdXJjZS5jdXJyZW50LmNhbmNlbCgnT3BlcmF0aW9uIGNhbmNlbGVkIGR1ZSB0byBuZXcgcmVxdWVzdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNhbmNlbCB0b2tlblxuICAgICAgcmVuZXdTZXNzaW9uQ2FuY2VsU291cmNlLmN1cnJlbnQgPSBheGlvcy5DYW5jZWxUb2tlbi5zb3VyY2UoKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1JlbmV3aW5nIHNlc3Npb24nKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLnBvc3QoJy9hdXRoL3JlbmV3LXNlc3Npb24nLCBcbiAgICAgICAgeyByZWZyZXNoVG9rZW4gfSwgXG4gICAgICAgIHsgY2FuY2VsVG9rZW46IHJlbmV3U2Vzc2lvbkNhbmNlbFNvdXJjZS5jdXJyZW50LnRva2VuIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRva2Vuc1xuICAgICAgICBjb25zdCBuZXdBY2Nlc3NUb2tlbiA9IHJlc3BvbnNlLmRhdGEuZGF0YS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgY29uc3QgbmV3UmVmcmVzaFRva2VuID0gcmVzcG9uc2UuZGF0YS5kYXRhLnJlZnJlc2hUb2tlbjtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIHJlbmV3ZWQgc3VjY2Vzc2Z1bGx5LCByZWNlaXZlZCBuZXcgdG9rZW5zJyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhY2Nlc3NUb2tlbicsIG5ld0FjY2Vzc1Rva2VuKTtcbiAgICAgICAgaWYgKG5ld1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdyZWZyZXNoVG9rZW4nLCBuZXdSZWZyZXNoVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgYXBpLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7bmV3QWNjZXNzVG9rZW59YDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChheGlvcy5pc0NhbmNlbChlcnJvcikpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlcXVlc3QgY2FuY2VsZWQ6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIHJlbmV3YWwgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVwbGFjZSB0aGUgY3VycmVudCB2ZXJpZnlTZXNzaW9uIHdpdGggdGhpcyBtb2R1bGFyIGFwcHJvYWNoXG4gIGNvbnN0IHZlcmlmeVNlc3Npb24gPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgc2Vzc2lvbiB2ZXJpZmljYXRpb24gcHJvY2VzcycpO1xuICAgICAgXG4gICAgICAvLyBHZXQgcmVmcmVzaCB0b2tlblxuICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3JlZnJlc2hUb2tlbicpO1xuICAgICAgXG4gICAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyByZWZyZXNoIHRva2VuIGF2YWlsYWJsZScpO1xuICAgICAgICBhd2FpdCBsb2dvdXQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGaXJzdCBqdXN0IGNoZWNrIGlmIHNlc3Npb24gaXMgdmFsaWRcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCBjaGVja1Nlc3Npb24ocmVmcmVzaFRva2VuKTtcbiAgICAgIFxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIGludmFsaWQsIGxvZ2dpbmcgb3V0Jyk7XG4gICAgICAgIC8vIFVzZSB0aGUgZXhpc3RpbmcgbG9nb3V0IGZ1bmN0aW9uIHRoYXQgd2Uga25vdyB3b3Jrc1xuICAgICAgICBhd2FpdCBsb2dvdXQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB2YWxpZCwgcmVuZXcgdGhlIHNlc3Npb25cbiAgICAgIGNvbnN0IHJlbmV3ZWQgPSBhd2FpdCByZW5ld1Nlc3Npb24ocmVmcmVzaFRva2VuKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZW5ld2VkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIHJlbmV3YWwgZmFpbGVkLCBsb2dnaW5nIG91dCcpO1xuICAgICAgICBhd2FpdCBsb2dvdXQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Nlc3Npb24gdmVyaWZpY2F0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoYW5nZSBlbWFpbCBmdW5jdGlvblxuICBjb25zdCBjaGFuZ2VFbWFpbCA9IGFzeW5jIChuZXdFbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9jaGFuZ2UtZW1haWwnLCB7IFxuICAgICAgICBuZXdFbWFpbCwgXG4gICAgICAgIHBhc3N3b3JkIFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB1c2VyIGluIHN0YXRlIHdpdGggbmV3IGVtYWlsXG4gICAgICAgIHNldFVzZXIocHJldlVzZXIgPT4gcHJldlVzZXIgPyB7IC4uLnByZXZVc2VyLCBlbWFpbDogbmV3RW1haWwgfSA6IG51bGwpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiAncmVzcG9uc2UnIGluIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZSBhcyBhbnk7XG4gICAgICAgIHNldEVycm9yKGVycm9yUmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgZW1haWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGVtYWlsJyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hhbmdlIHBhc3N3b3JkIGZ1bmN0aW9uXG4gIGNvbnN0IGNoYW5nZVBhc3N3b3JkID0gYXN5bmMgKGN1cnJlbnRQYXNzd29yZDogc3RyaW5nLCBuZXdQYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wb3N0KCcvYXV0aC9jaGFuZ2UtcGFzc3dvcmQnLCB7IFxuICAgICAgICBjdXJyZW50UGFzc3dvcmQsIFxuICAgICAgICBuZXdQYXNzd29yZCBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIC8vIExvZ291dCBhZnRlciBwYXNzd29yZCBjaGFuZ2UgYXMgYWxsIHNlc3Npb25zIGFyZSBpbnZhbGlkYXRlZFxuICAgICAgICAvLyBhd2FpdCBsb2dvdXQoKTtcbiAgICAgICAgLy8gc2V0VXNlcihwcmV2VXNlciA9PiBwcmV2VXNlciA/IHsgLi4ucHJldlVzZXIsIGN1cnJlbnRQYXNzd29yZDogbmV3UGFzc3dvcmR9IDogbnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdyZXNwb25zZScgaW4gZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlIGFzIGFueTtcbiAgICAgICAgc2V0RXJyb3IoZXJyb3JSZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBwYXNzd29yZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgcGFzc3dvcmQnKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGFuZ2UgdXNlcm5hbWUgZnVuY3Rpb25cbiAgY29uc3QgY2hhbmdlVXNlcm5hbWUgPSBhc3luYyAobmV3VXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdCgnL2F1dGgvY2hhbmdlLXVzZXJuYW1lJywgeyBcbiAgICAgICAgbmV3VXNlcm5hbWUgXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHVzZXIgaW4gc3RhdGUgd2l0aCBuZXcgdXNlcm5hbWVcbiAgICAgICAgc2V0VXNlcihwcmV2VXNlciA9PiBwcmV2VXNlciA/IHsgLi4ucHJldlVzZXIsIHVzZXJuYW1lOiBuZXdVc2VybmFtZSB9IDogbnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICdyZXNwb25zZScgaW4gZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlIGFzIGFueTtcbiAgICAgICAgc2V0RXJyb3IoZXJyb3JSZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwZGF0ZSB1c2VybmFtZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgdXNlcm5hbWUnKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgXG4gIHJldHVybiAoXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICB1c2VyLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogISF1c2VyLFxuICAgICAgICBsb2dpbixcbiAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgIGxvZ291dCxcbiAgICAgICAgdmVyaWZ5U2Vzc2lvbixcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGNoYW5nZUVtYWlsLFxuICAgICAgICBjaGFuZ2VQYXNzd29yZCxcbiAgICAgICAgY2hhbmdlVXNlcm5hbWUsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuLy8gQ3VzdG9tIGhvb2sgZm9yIHVzaW5nIGF1dGggY29udGV4dFxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcbiAgXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUF1dGggbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBBdXRoUHJvdmlkZXInKTtcbiAgfVxuICBcbiAgcmV0dXJuIGNvbnRleHQ7XG59OyAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiYXhpb3MiLCJ1c2VSb3V0ZXIiLCJBdXRoQ29udGV4dCIsInVuZGVmaW5lZCIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIndpdGhDcmVkZW50aWFscyIsImludGVyY2VwdG9ycyIsInJlc3BvbnNlIiwidXNlIiwiZXJyb3IiLCJvcmlnaW5hbFJlcXVlc3QiLCJjb25maWciLCJpc0F1dGhFbmRwb2ludCIsInVybCIsImluY2x1ZGVzIiwic3RhdHVzIiwiX3JldHJ5Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiUHJvbWlzZSIsInJlamVjdCIsInJlZnJlc2hFcnJvciIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic2V0RXJyb3IiLCJyb3V0ZXIiLCJjaGVja1Nlc3Npb25DYW5jZWxTb3VyY2UiLCJyZW5ld1Nlc3Npb25DYW5jZWxTb3VyY2UiLCJjaGVja0F1dGgiLCJ0b2tlbiIsImdldEl0ZW0iLCJkZWZhdWx0cyIsImhlYWRlcnMiLCJjb21tb24iLCJkYXRhIiwiZ2V0Iiwic3VjY2VzcyIsImxvZ2luIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImNvbnNvbGUiLCJsb2ciLCJwb3N0Iiwic2V0SXRlbSIsInRva2VucyIsImFjY2Vzc1Rva2VuIiwicmVmcmVzaFRva2VuIiwicHVzaCIsImVycm9yUmVzcG9uc2UiLCJtZXNzYWdlIiwicmVnaXN0ZXIiLCJlbWFpbCIsImxvZ291dCIsImNoZWNrU2Vzc2lvbiIsImN1cnJlbnQiLCJjYW5jZWwiLCJDYW5jZWxUb2tlbiIsInNvdXJjZSIsImNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJyZW5ld1Nlc3Npb24iLCJuZXdBY2Nlc3NUb2tlbiIsIm5ld1JlZnJlc2hUb2tlbiIsInZlcmlmeVNlc3Npb24iLCJpc1ZhbGlkIiwicmVuZXdlZCIsImNoYW5nZUVtYWlsIiwibmV3RW1haWwiLCJwcmV2VXNlciIsImNoYW5nZVBhc3N3b3JkIiwiY3VycmVudFBhc3N3b3JkIiwibmV3UGFzc3dvcmQiLCJjaGFuZ2VVc2VybmFtZSIsIm5ld1VzZXJuYW1lIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImlzQXV0aGVudGljYXRlZCIsInVzZUF1dGgiLCJjb250ZXh0IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/AuthContext.tsx\n"));

/***/ })

});